<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Moving sphere in an infinite fluid · FinEtoolsAcoustics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FinEtoolsAcoustics.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../guide/guide.html">How to guide</a></li><li><span class="tocitem">Types and Functions</span><ul><li><a class="tocitem" href="../man/types.html">Types</a></li><li><a class="tocitem" href="../man/functions.html">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="sphere_dipole_tut.html">Moving sphere in an infinite fluid</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="sphere_dipole_tut.html">Moving sphere in an infinite fluid</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsAcoustics.jl/blob/master/docs/src/tutorials/sphere_dipole_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Moving-sphere-in-an-infinite-fluid"><a class="docs-heading-anchor" href="#Moving-sphere-in-an-infinite-fluid">Moving sphere in an infinite fluid</a><a id="Moving-sphere-in-an-infinite-fluid-1"></a><a class="docs-heading-anchor-permalink" href="#Moving-sphere-in-an-infinite-fluid" title="Permalink"></a></h1><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>A rigid sphere in an infinite volume of fluid accelerates alternately in the positive and negative x-direction, generating positive pressure ahead of it, negative pressure behind. Time-dependent simulation. Described in [1].</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] Krysl P, Hawkins AD, Schilt C, Cranford TW (2012): Angular Oscillation of Solid Scatterers in Response to Progressive Planar Acoustic Waves: Do Fish Otoliths Rock?. PLOS ONE 7(8): e42591. https://doi.org/10.1371/journal.pone.0042591</p><p><img src="sphere_dipole.png" alt/></p><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Show how to generate hexahedral mesh, mirroring and merging together parts.</li><li>Execute transient simulation by the trapezoidal-rule time stepping of [1].</li></ul><pre><code class="language-julia">#</code></pre><h2 id="Definitions"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></h2><p>The finite element code relies on the basic functionality implemented in this package.</p><pre><code class="language-julia">using FinEtools</code></pre><p>The acoustics functionality is brought in:</p><pre><code class="language-julia">using FinEtoolsAcoustics</code></pre><p>We shall need some facilities from the linear algebra package</p><pre><code class="language-julia">using LinearAlgebra</code></pre><p>The properties correspond roughly to air.</p><pre><code class="language-julia">rho = 1.21*phun(&quot;kg/m^3&quot;);# mass density
c  = 343.0*phun(&quot;m/s&quot;);# sound speed
bulk =  c^2*rho;
a_amplitude=1.0*phun(&quot;mm/s^2&quot;);# amplitude of the  acceleration of the sphere
R = 50.0*phun(&quot;mm&quot;); # radius of the interior sphere
Ro = 8*R # radius of the external sphere, where the fluid doing this truncated
P_amplitude = R*rho*a_amplitude; # pressure amplitude
frequency = 1200.; # # frequency of the incident wave, Hz
omega = 2*pi*frequency;
dt = 1.0/frequency/20;
tfinal = 90*dt;
nsteps = round(tfinal/dt)+1;</code></pre><p>This dictates the parameters of the mesh.</p><pre><code class="language-julia">nref = 2;
nlayers = 40;
tolerance  =  Ro/(nlayers)/100</code></pre><p>Hexahedral mesh: Generate 1/8 of the scattering sphere. This sphere is not actually part of the model, it just serves as an intermediate step from which the volume of the fluid will be produced.</p><pre><code class="language-julia">fens, fes  =  H8sphere(R, nref);</code></pre><p>No mirror the 1/8 of the sphere to build one fourth of the complete three-dimensional geometry. In other words we are using two symmetric planes here. Note that in order to mirror the hexahedral elements correctly, we need to specify the renumbering rule for the connectivity.</p><pre><code class="language-julia">fens1, fes1  =  mirrormesh(fens, fes, [-1.0, 0.0, 0.0], [0.0, 0.0, 0.0], renumb =  r(c) = c[[1, 4, 3, 2, 5, 8, 7, 6]]);</code></pre><p>Now merge the two pieces (1/8) together.</p><pre><code class="language-julia">fens,newfes1,fes2 =  mergemeshes(fens1, fes1, fens, fes, tolerance)
fes = cat(newfes1,fes2)</code></pre><p>Derive the finite element set for the boundary of the target.</p><pre><code class="language-julia">bfes  =  meshboundary(fes)</code></pre><p>To identify the outer spherical boundary we&#39;ll use this function to calculate its normal.</p><pre><code class="language-julia">function dout(xyz)
    return xyz/norm(xyz)
end</code></pre><p>Select the part of the boundary of the target facing towards infinity.</p><pre><code class="language-julia">louter = selectelem(fens, bfes, facing = true, direction = dout)
outer_fes = subset(bfes, louter);</code></pre><p>The surface of the spherical target is now extruded into multiple layers.</p><pre><code class="language-julia">fens,fes  = H8extrudeQ4(fens, outer_fes, nlayers, (xyz, layer)-&gt;(R+layer/nlayers*(Ro-R))*xyz/norm(xyz));</code></pre><p>In case there are any unconnected nodes, remove them, and renumber the elements.</p><pre><code class="language-julia">connected = findunconnnodes(fens, fes);
fens, new_numbering = compactnodes(fens, connected);
fess = renumberconn!(fes, new_numbering);</code></pre><p>The geometry and the solution (pressure) fields.</p><pre><code class="language-julia">geom  =  NodalField(fens.xyz)
P  =  NodalField(zeros(FCplxFlt,size(fens.xyz,1),1))</code></pre><p>We need to identify the surface of the scattering sphere, and also the outside sphere where the fluid immediately surrounding the sphere is adjacent to the infinite extent of the fluid.</p><pre><code class="language-julia">bfes  =  meshboundary(fes)</code></pre><p>Find the two spherical surfaces, one can be located by the distance criterion (from the center), and the other one by facing to infinity (away from the center).</p><pre><code class="language-julia">linner = selectelem(fens, bfes, distance = R, from = [0.0 0.0 0.0], inflate = tolerance)
louter = selectelem(fens, bfes, facing = true, direction = dout)

#</code></pre><h2 id="Visualize-the-geometry"><a class="docs-heading-anchor" href="#Visualize-the-geometry">Visualize the geometry</a><a id="Visualize-the-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-the-geometry" title="Permalink"></a></h2><p>Export three VTK files: one for the interior of the fluid, and two for the boundaries. The boundaries on the symmetry planes are taken into account implicitly.</p><pre><code class="language-julia">File  =   &quot;Sphere-fluid-interior.vtk&quot;
vtkexportmesh(File, fes.conn, fens.xyz, FinEtools.MeshExportModule.VTK.H8)
File  =   &quot;Sphere-fluid-inner-boundary.vtk&quot;
vtkexportmesh(File, subset(bfes, linner).conn, geom.values, FinEtools.MeshExportModule.VTK.Q4)
File  =   &quot;Sphere-fluid-outer-boundary.vtk&quot;
vtkexportmesh(File, subset(bfes, louter).conn, geom.values, FinEtools.MeshExportModule.VTK.Q4)</code></pre><p>If we have paraview, we can run it now.</p><pre><code class="language-julia">@async run(`&quot;paraview.exe&quot; $File`)

#</code></pre><h2 id="Set-up-the-discrete-model"><a class="docs-heading-anchor" href="#Set-up-the-discrete-model">Set up the discrete model</a><a id="Set-up-the-discrete-model-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-discrete-model" title="Permalink"></a></h2><p>Number the degrees of freedom in the pressure field.</p><pre><code class="language-julia">numberdofs!(P)</code></pre><p>Create the finite element machine for the fluid.</p><pre><code class="language-julia">material = MatAcoustFluid(bulk,rho)
femm  =  FEMMAcoust(IntegDomain(fes, GaussRule(3, 2)), material)</code></pre><p>Use the machine calculate the acoustic stiffness and mass matrices.</p><pre><code class="language-julia">S  =  acousticstiffness(femm, geom, P);
C  =  acousticmass(femm, geom, P);</code></pre><p>Set up finite element machine needed for the absorbing boundary conditions.</p><pre><code class="language-julia">abcfemm  =  FEMMAcoustSurf(IntegDomain(subset(bfes, louter), GaussRule(2, 2)), material)</code></pre><p>This is the &quot;damping&quot; mmatrix for the ABC.</p><pre><code class="language-julia">D  =  acousticABC(abcfemm, geom, P);</code></pre><p>The sphere at the center is rigid and moves in a prescribed, harmonic, fashion. That generates loading onto the fluid. We expect the loading to be in the form of a dipole.</p><pre><code class="language-julia">function dipole(dpdn, xyz, J, label, t)
    n = cross(J[:,1],J[:,2]);
    n = vec(n/norm(n));
    dpdn[1] = -rho*a_amplitude*sin(omega*t)*n[1]
end</code></pre><p>In order to evaluate the distributed pressure flux loading we need a surface acoustic finite element model machine. We shall set it up for the interior spherical surface.</p><pre><code class="language-julia">dipfemm  =  FEMMAcoustSurf(IntegDomain(subset(bfes, linner), GaussRule(2, 2)), material)

#</code></pre><h2 id="Time-stepping"><a class="docs-heading-anchor" href="#Time-stepping">Time stepping</a><a id="Time-stepping-1"></a><a class="docs-heading-anchor-permalink" href="#Time-stepping" title="Permalink"></a></h2><p>Solve the transient acoustics equations. Refer to [1] for details of the formulation.</p><p>The loop executes inside this local scope.</p><pre><code class="language-julia">P1 = let
    P0 = deepcopy(P)
    P0.values[:] .= 0.0; # initially all pressure is zero
    vP0 = gathersysvec(P0);
    vQ0 = zeros(eltype(vP0), size(vP0));</code></pre><p>The <code>P1</code> field will be the output of this computation: the final value of the pressure field</p><pre><code class="language-julia">    P1 = deepcopy(P0);

    t = 0.0; # Initial time</code></pre><p>Compute the initial load due to the pressure gradient on the surface of the moving sphere.</p><pre><code class="language-julia">    fi  =  ForceIntensity(FCplxFlt, 1, (dpdn, xyz, J, label)-&gt;dipole(dpdn, xyz, J, label, t));
    La0 = distribloads(dipfemm, geom, P1, fi, 2);</code></pre><p>This is the coefficient matrix that needs to be used in the solves. We are not being very careful here to save on computation: it might be best to factorize this matrix, and then use backward and forward solves inside the loop.</p><pre><code class="language-julia">    A = (2.0/dt)*S + D + (dt/2.)*C;

    step = 0;
    while t &lt;= tfinal
        step = step  + 1;
        println(&quot;Time $t ($(step)/$(round(tfinal/dt)+1))&quot;)
        t = t+dt;</code></pre><p>Compute the current load due to the pressure gradient on the surface of the moving sphere.</p><pre><code class="language-julia">        fi  = ForceIntensity(FCplxFlt, 1, (dpdn, xyz, J, label)-&gt;dipole(dpdn, xyz, J, label, t));
        La1 = distribloads(dipfemm, geom, P1, fi, 2);</code></pre><p>Solve for the rate of the pressure</p><pre><code class="language-julia">        vQ1 = A\((2/dt)*(S*vQ0)-D*vQ0-C*(2*vP0+(dt/2)*vQ0)+La0+La1);</code></pre><p>Update the value of the pressure</p><pre><code class="language-julia">        vP1 = vP0 + (dt/2)*(vQ0+vQ1);</code></pre><p>Swap variables for next step</p><pre><code class="language-julia">        vP0 = vP1;
        vQ0 = vQ1;
        P1 = scattersysvec!(P1, vec(vP1));
        P0 = P1;
        La0 = La1;
    end

    P1 # Return the final pressure
end

#</code></pre><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><pre><code class="language-julia">File  =   &quot;sphere_dipole_P1.vtk&quot;
vtkexportmesh(File, fes.conn, geom.values, FinEtools.MeshExportModule.VTK.H8; scalars = [( &quot;realP&quot;, real.(P1.values)),])
@async run(`&quot;paraview.exe&quot; $File`)


true</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 20 August 2020 22:54">Thursday 20 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
